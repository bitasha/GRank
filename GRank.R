library(igraph)
#rmat: rating matrix m*n
#usersequence: a list of array such that  userSeq[[i]] contains items that are rated by i-th user 
#       (is generated by makeUserseq function)

#rl: length of recommendation list (NDCG@rl)
#trl : length of traiing profile of each user (i.e. UPL)
#nl:  length of neighborhood size (typically set to 100)
#direc: the direction of check point recorder 
#trdirec: the direction for training file if available 
#first run : a logic variable to indicate if the evaluation should be initialized or it should be continued based on the check point file
#dampingFactor: the damping factor for graph-based similarity measure
#simdirec: the direction to store and read similarity values ( that can be helpful for ....)
#simflag: a logical variable to indicate similarity should be calculated(0) or load from file(1)
#trainflag:a logical variable to indicate training set  should be generated randomly(0) or load from file(1)
rankEvaluation_Yu_GRank<-function(rmat,userSeq,rl=c(1,3,5,10),trl,direc,firstRun,simflag=0,trainflag=0,damping=0.85,trdirec){
  
  userLength= calUserLength(userSeq);
  NDCG=matrix(0,length(trl),length(rl));  
  count=matrix(0,length(trl),length(rl));
  param=c(1,1,0,0)
  tt=0;
  tt2=0;
  if(firstRun==0){
    direcFile=read.csv(direc)
    direcFile=direcFile[,-1]
    param=as.numeric(direcFile[1,]);          st=2;     end=st+length(trl)-1;
    NDCG=data.matrix(direcFile[st:(end),]);     st=end+1; end=st+length(trl)-1;
    count=data.matrix(direcFile[st:end,]);  
    userLength= calUserLength(userSeq); tt=0;
    tt2=param[4];
  }
  
  for(w in param[1]:length(trl)){            
    j=trl[w]
    t=Yu_prepareData(rmat,j+max(rl),userSeq);
    userSeq=t@us;
    rmat=t@rmat2;

    for(i in param[2]:1){
      #trList and testListindices of user in train and tes
      testSet= 1:nrow(rmat);
      trList=c(1:nrow(rmat));
      tr=trList_random(userSeq,j,testSet); 
      if(trainflag==1){
        x=read.csv(trdirec);x=x[,-1]
        tr=lapply(seq_len(nrow(x)),function(i) as.numeric(x[i,]))
      }
   
      ###**********************************
        trMat=makeTrainMat(tr,rmat);
        tt<-tt+system.time(l<-makeTPG(trMat,tr));
        g<-graph.edgelist(l[,1:2],directed = F);
        
        
      
      for(uid in (param[3]+1):length(testSet)){
        if((uid%%50)==0)
          gc(T);
        tp={};
        for(h in 1:length(tr[[testSet[[uid]]]])){
          tp=c(tp,which(userSeq[[testSet[uid]]]==tr[[uid]][h]))
        }
        ts=userSeq[[testSet[uid]]][-tp];
        
        sh=1;
        
        tt=tt+system.time(f<-makeRecommendation(g,uid,rmat =rmat,damping = damping));
        for(d in 1:length(rl)){
          topK=rl[d];
          r=order(f,decreasing=T);
          r=intersect(r,ts);
          recomList=r[1:topK];
          count[w,d]=count[w,d]+1;
          NDCG[w,d]=NDCG[w,d]+calNDCG(f[ts],rmat[testSet[uid],ts],topK);
        }
          if(uid%%50==0){        
            print(c(uid,NDCG/count))
            checkRes=rbind(c(w,i,uid,tt2[1]),NDCG,count);
            write.csv(checkRes,direc);
          }
      }
      
      checkRes=rbind(c(w,i,uid,tt2[1]),NDCG,count);
      
      write.csv(checkRes,direc);
      
    }
    print("NDCG")
    print(NDCG/count)
    print(c("tt",tt));
    # prec=prec/(count);    
    # reca=reca/(count);
    # NDCG=NDCG/(count);
    
  }    
  
  ev=setClass("ev",slots=c("NDCGALL","count","t1"));
  evt=new("ev",NDCGALL=NDCG/count,count=count,t1=tt2);                        
  return(evt)
}

#graph construction
#rmat: rating matrix 
#us: the usersequcne 
#tr: training list of all users
makeTPG<-function(rmat,tr){
  print("constructing graph")
  l=rep(0,2);
  count=1
  countp=0;
  t2=matrix(0,5000,2);
  t3=rep(0,2);
  
  for(i in 1:nrow(rmat)){
    uid=i;
    print(uid)
    r=tr[[uid]]
    s=splitRating(rmat,uid,r);
    m=0;
    if(length(s)>1){
      for( uu in 1:(length(s)-1))
        for(hh in (uu+1):(length(s)))
          m=m+length(s[[hh]])*length(s[[uu]]);
        t2=matrix(0,m,2)
        if((countp%%10000)==0)
          print(i)
        for(j in 1:(length(s)-1)){
          for(k in ((j+1):length(s))){
            if(length(s[[j]])>0&&length(s[[k]])>0){
              t=tList(i,s[[j]],s[[k]],rmat)
              countp=countp+nrow(t);
              tl=count+nrow(t)-1;
              t2[count:tl,]=t;
              count=count+nrow(t);
              
            }
          }
        }    
        
        t3=rbind(t3,t2);   
    }
    count=1;
  }
  if(countp>0){
    print(c(dim(l),dim(t3),dim(t3[-1,])))
    l=rbind(l,t3[-1,]);
  }
  print("L3")
  l=l[-1,]
  st=nrow(rmat)+1;
  end=nrow(rmat)+ncol(rmat)*ncol(rmat);
  u=matrix(0,2*ncol(rmat)*ncol(rmat),2)
  rc=1;
  for(k in st:end){
    q=rep(0,2);
    t=ceiling((k-st+1)/ncol(rmat)); #node barande
    t2=(k-st+1)%% ncol(rmat);#node bazande    
    if(t2==0){
      t2=ncol(rmat);
    }
    q=rbind(q,c(k,end+2*t-1));
    q=rbind(q,c(k,end+2*t2));    
    u[rc:(rc+1),]=q[-1,];
    rc=rc+2
  }
  print("graph is constructed")
  l=rbind(l,u)
  return(l);
}
ppr<-function(g, personalized=rep(1/vcount(g),vcount(g)),damping=0.85){
  personalized=personalized/sum(personalized)
  r=(get.adjacency(g));
  e=(drop0(r))
  p=colSums(e);
  e=crossprod(r,solve(Diagonal(x=p)))
  m=runif(length(personalized))
  #m=rep(1,length(personalized))
  m=m/sum(m)
  m=matrix(m,length(m),1)
  er=rep(0,100)
  l=which(personalized!=0)
  for(i in 1:20){  
    m2=damping*(e%*%m)+(1-damping)*personalized;
    er[i]=sum((m-m2)^2);
    m=m2
    #aa=(1-sum(m))/length(m)
    m=m/sum(m)
    #if(er[i]<0.000001)
    # break;
  }
  return(m)
}


#Recommendation function: this function scores items for user with id: id 
#g: TPG graph constructed by function make3LGraph_2
#id: the id of the target user 
#rmat: the rating matrix
#the damping factor of personalized PageRank
makeRecommendation<-function(g,id,rmat,damping=0.85){
  r=rep(0,vcount(g))
  r[id]=1;
  pref=ppr(g,r,damping);
  #pref=page.rank(g,personalized = r)$vector
  end=vcount(g)-2*ncol(rmat);
  l2=rep(0,ncol(rmat));
  v=pref[seq(from=(end+1),to=length(pref),by=2)]
  v2=pref[seq(from=(end+2),to=length(pref),by=2)]
  l2=(v)/(v+v2)
  rm(v);
  rm(pref);
  rm(v2);
  rm(g);
  rm(id);
  rm(tr);
  return(l2);  
}

